const { SlashCommandBuilder } = require('discord.js');
const { joinVoiceChannel } = require('@discordjs/voice');
const ytdl = require('@distube/ytdl-core');
const YouTube = require('youtube-sr').default;

module.exports = {
    data: new SlashCommandBuilder()
        .setName('play')
        .setDescription('YouTube URL ‡§Ø‡§æ ‡§ó‡§æ‡§®‡•á ‡§ï‡§æ ‡§®‡§æ‡§Æ ‡§∏‡•á play ‡§ï‡§∞‡•á‡§Ç')
        .addStringOption(option =>
            option.setName('query')
                .setDescription('YouTube URL ‡§Ø‡§æ ‡§ó‡§æ‡§®‡•á ‡§ï‡§æ ‡§®‡§æ‡§Æ')
                .setRequired(true)
        ),

    async execute(interaction) {
        await interaction.deferReply();

        const member = interaction.member;
        if (!member) {
            return interaction.editReply('‚ùå Member information not available. Please try again.');
        }
        
        const voiceChannel = member.voice?.channel;
        const query = interaction.options.getString('query');

        if (!voiceChannel) {
            return interaction.editReply('‚ùå ‡§Ü‡§™‡§ï‡•ã ‡§™‡§π‡§≤‡•á ‡§ï‡§ø‡§∏‡•Ä voice channel ‡§Æ‡•á‡§Ç join ‡§ï‡§∞‡§®‡§æ ‡§π‡•ã‡§ó‡§æ!');
        }

        try {
            let videoUrl, title, duration, thumbnail;

            // Check if it's a URL or search query
            if (ytdl.validateURL(query)) {
                // It's a URL
                videoUrl = query;
                const info = await ytdl.getInfo(videoUrl);
                title = info.videoDetails.title;
                duration = parseInt(info.videoDetails.lengthSeconds);
                thumbnail = info.videoDetails.thumbnails[0]?.url;
            } else {
                // It's a search query
                const searchResults = await YouTube.search(query, { limit: 1 });
                if (!searchResults || searchResults.length === 0) {
                    return interaction.editReply('‚ùå ‡§ï‡•ã‡§à ‡§ó‡§æ‡§®‡§æ ‡§®‡§π‡•Ä‡§Ç ‡§Æ‡§ø‡§≤‡§æ! ‡§¶‡•Ç‡§∏‡§∞‡§æ ‡§®‡§æ‡§Æ try ‡§ï‡§∞‡•á‡§Ç‡•§');
                }
                
                const video = searchResults[0];
                videoUrl = video.url;
                title = video.title;
                duration = video.durationInSec || 0;
                thumbnail = video.thumbnail?.url;
            }

            const song = {
                title,
                url: videoUrl,
                duration,
                thumbnail,
                requestedBy: interaction.user,
            };

            // Join voice channel if not already connected
            let connection;
            try {
                connection = joinVoiceChannel({
                    channelId: voiceChannel.id,
                    guildId: interaction.guild.id,
                    adapterCreator: interaction.guild.voiceAdapterCreator,
                });
            } catch (error) {
                console.log('Already connected or connection exists');
            }

            const queue = global.getQueue(interaction.guild.id);
            const player = global.createGuildAudioPlayer(interaction.guild.id);
            
            if (connection) {
                connection.subscribe(player);
            }

            if (queue.nowPlaying) {
                // Add to queue
                queue.add(song);
                return interaction.editReply(`üìã **${title}** ‡§ï‡•ã queue ‡§Æ‡•á‡§Ç add ‡§ï‡§∞ ‡§¶‡§ø‡§Ø‡§æ! Position: ${queue.songs.length}`);
            } else {
                // Play immediately
                queue.add(song);
                global.playNext(interaction.guild.id);
                return interaction.editReply(`üéµ ‡§Ö‡§¨ play ‡§π‡•ã ‡§∞‡§π‡§æ ‡§π‡•à: **${title}**`);
            }

        } catch (error) {
            console.error('Play command error:', error);
            return interaction.editReply('‚ùå ‡§ó‡§æ‡§®‡§æ play ‡§ï‡§∞‡§®‡•á ‡§Æ‡•á‡§Ç error ‡§π‡•Å‡§à! ‡§¶‡•Ç‡§∏‡§∞‡§æ ‡§ó‡§æ‡§®‡§æ try ‡§ï‡§∞‡•á‡§Ç‡•§');
        }
    },
};